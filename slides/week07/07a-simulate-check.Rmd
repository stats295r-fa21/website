---
title: "Simulation and Control Structures"
author: "Dr. Mine Dogucu"
output: 
  xaringan::moon_reader:
    css: slide-style.css
    seal: false
    nature:
      ratio: 16:9
      highlightStyle: "pygments"
      highlightLines: true
      highlightLanguage: "r"
---

class: title-slide

```{r child = "../setup.Rmd"}
```

```{r echo = FALSE, message = FALSE}
library(tidyverse)
options(scipen = 999)
```

<br>
<br>
.right-panel[ 

# `r rmarkdown::metadata$title`
## `r rmarkdown::metadata$author`
]

---

class: middle

## Goals

- Probability Distribution and simulating data in R

- Control structures (if/else, for and while loops and mapping)



---

class: middle

- Go to course organization on GitHub
- Start a new repo called `week-07-simulate-data-username` where username represents your own username.

---

#### Probability Distributions - Normal

```{r}
dnorm(x = -1.96, mean = 0, sd = 1)
pnorm(q = -1.96, mean = 0, sd = 1)
qnorm(p = 0.0249979, mean = 0, sd = 1, lower.tail = TRUE)
rnorm(n = 3, mean = 0, sd = 1)
```

---

## Probability Distributions - Normal

.pull-left[

```{r eval = FALSE}
ggplot(data = data.frame(x = c(-3, 3)), aes(x)) +
  stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1)) + ylab("") +
  scale_y_continuous(breaks = NULL)
```

]


.pull-right[

```{r echo = FALSE}
ggplot(data = data.frame(x = c(-3, 3)), 
       aes(x)) +
  stat_function(fun = dnorm, 
                n = 101, 
                args =list(mean = 0, sd = 1)) +
  ylab("") +
  scale_y_continuous(breaks = NULL)
```

]

---

class: middle

## Other probability Functions

- `dbinom()`, `pbinom()`, `qbinom()`, `rbinom()`
- `dbeta()`, `pbeta()`, `qbeta()`, `rbeta()`
- `dunif()`, `punif()`, `qunif()`, `runif()`

---

class: middle

```{r}
runif(1)
```


```{r}
set.seed(92697)
runif(1)
```

`set.seed()` allows reproducibility of results when randomness is introduced.

---

## `while` loops

.pull-left[
```{r}

count <- 0

while(count < 10) {
  count <- count + 1 
  print(count)
}

```
]

.pull-right[
```{r}

count <- 0

while(count < 10) {
  print(count)
  count <- count + 1 
}

```
]

---

## if/else

```{r eval=FALSE}

if(condition) {
  ## do something
}

## Rest of the code

```

```{r eval=FALSE}

if(condition) {
  ## do something
} else {
  ## do something else
}

```

```{r eval=FALSE}
if(condition) {
  ## do something
  } else if(another condition) {
  ## do something different
  } else {
    ## do something different
}
```

---

```{r}

count <- 0

while(count < 10) {
  if(count < 5){
    print(paste(count, "small number"))
  }
  count <- count + 1 
}

```

---

```{r}

count <- 0

while(count < 10) {
  if(count %% 2 == 0){
    print(paste(count, "even number"))
  }
  count <- count + 1 
}

```

---

```{r}

count <- 0

while(count < 10) {
  if(count %% 2 == 0){
    print(paste(count, "even number"))
  } else {
    print(paste(count, "odd number"))
  }
  count <- count + 1 
}

```

---

## for loops

```{r}
for (i in 1:10){
  print(i)
}
```

---

## for loops



```{r}

sample_size <- c(30, 60, 100)
for (i in 1:3){
  print(sample_size[i])
}
```

```{r}

sample_size <- c(30, 60, 100)
for (i in 1:length(sample_size)){
  print(sample_size[i])
}
```

---

### apply : R Documentation

Returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.


`apply(X, MARGIN, FUN, ..., simplify = TRUE)`

`X`	an array, including a matrix.

`MARGIN`	a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.

`FUN`	the function to be applied: see ‘Details’. In the case of functions like +, %*%, etc., the function name must be backquoted or quoted.

optional arguments to FUN.

---

class: middle

```{r}
some_matrix <- matrix(C <- (1:30), nrow = 5, ncol = 6)
some_matrix
apply(some_matrix, 1, sum) # adding rows
apply(some_matrix, 2, sum) # adding columns

```


---

class: middle


### lapply and sapply: R Documentation

Apply a Function over a List or Vector
Description

`lapply` returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X.

`sapply` is a user-friendly version and wrapper of lapply by default returning a vector, matrix or, if simplify = "array", an array if appropriate, by applying simplify2array(). sapply(x, f, simplify = FALSE, USE.NAMES = FALSE) is the same as lapply(x, f).

---

class: middle

.pull-left[
```{r}
sapply(c(0, 1, 2), exp)

```

]

.pull-right[
```{r}
lapply(c(0, 1, 2), exp)

```

]
---
class: middle

.pull-left[
```{r}
sapply(c(0, 1, 2), exp)

```

]

.pull-right[
```{r}
lapply(c(0, 1, 2), exp) %>% 
  unlist()

```

]

---

class: middle

This week's (long) task: 

How does missing data (missing completely at random) impact bias and variance in simple linear regression?

Design a simulation to answer this question.
You are in charge of developing sub-questions.
